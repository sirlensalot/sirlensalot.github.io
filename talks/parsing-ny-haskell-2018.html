<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Stuart Popejoy stuart@kadena.io @SirLensALot">
  <title>Parsing parsed parseables, from music to Megaparsec</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style type="text/css">
      code{white-space: pre-wrap;}
      .smallcaps{font-variant: small-caps;}
      .line-block{white-space: pre-line;}
      .column{display: inline-block;}
  </style>
  <style type="text/css">
div.sourceLine, a.sourceLine { display: inline-block; min-height: 1.25em; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; }
@media print {
code.sourceCode { white-space: pre-wrap; }
div.sourceLine, a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource div.sourceLine, .numberSource a.sourceLine
  { position: relative; }
pre.numberSource div.sourceLine::before, .numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em; }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; color: #aaaaaa;  padding-left: 4px; }
@media screen {
a.sourceLine::before { text-decoration: underline; color = initial; }
}
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.bn { color: #40a070; } /* BaseN */
code span.fl { color: #40a070; } /* Float */
code span.ch { color: #4070a0; } /* Char */
code span.st { color: #4070a0; } /* String */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.ot { color: #007020; } /* Other */
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.fu { color: #06287e; } /* Function */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code span.cn { color: #880000; } /* Constant */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.ss { color: #bb6688; } /* SpecialString */
code span.im { } /* Import */
code span.va { color: #19177c; } /* Variable */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.op { color: #666666; } /* Operator */
code span.bu { } /* BuiltIn */
code span.ex { } /* Extension */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.at { color: #7d9029; } /* Attribute */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/kadena-unbranded.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
  <h1 class="title">Parsing parsed parseables, from music to Megaparsec</h1>
  <p class="author">Stuart Popejoy stuart@kadena.io <span class="citation" data-cites="SirLensALot">@SirLensALot</span></p>
  <p class="date">NY Haskell, Oct 2018</p>
</section>

<section id="parsing-in-haskell" class="slide level1">
<h1>Parsing in Haskell</h1>
<ul>
<li>16:32 <strong>haskn00b</strong>: any pointers on good regex libs in haskell? thanks!</li>
<li>16:33 <strong>shw</strong>: yeah … parsec</li>
<li>16:33 <strong>haskn00b</strong>: cool!</li>
<li>16:53 <strong>haskn00b</strong>: shw: i don’t see the regex part. How am I supposed to handle text?</li>
<li>16:54 <strong>shw</strong>: Regex can deceive you. Stretch out with your feelings!</li>
<li>16:54 <strong>haskn00b</strong>: <em>writes entire app in bash</em></li>
</ul>
</section>
<section id="parser-combinators" class="slide level1">
<h1>Parser Combinators</h1>
<section id="a-greatest-hit-of-haskell" class="level2">
<h2>A “greatest hit” of Haskell</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="ot">expr ::</span> <span class="dt">CharParsing</span> m <span class="ot">=&gt;</span> m <span class="dt">Expr</span></div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">expr <span class="fu">=</span> (<span class="dt">ENumber</span> <span class="fu">&lt;$&gt;</span> scientific) <span class="fu">&lt;|&gt;</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">       (<span class="dt">EString</span> <span class="fu">&lt;$&gt;</span> stringLiteral) <span class="fu">&lt;|&gt;</span></div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">       (<span class="dt">EAtom</span> <span class="fu">&lt;$&gt;</span> identifier) <span class="fu">&lt;|&gt;</span></div>
<div class="sourceLine" id="5" href="#5" data-line-number="5">       (<span class="dt">EList</span> <span class="fu">&lt;$&gt;</span> parens (sepBy expr spaces))</div></code></pre>
<p>Absurdly expressive, BNF-like moxie</p>
</section>
<section id="main-elements" class="level2">
<h2>Main elements</h2>
<ul>
<li>Alternative: <code>&lt;|&gt;</code>, <code>empty</code>, <code>some</code>, <code>many</code></li>
<li>Functor: <code>&lt;$&gt;</code></li>
<li>Applicative: <code>pure</code>, <code>&lt;*&gt;</code>, <code>&lt;*</code>, <code>*&gt;</code></li>
<li>MonadPlus: <code>mzero</code>, <code>mplus</code></li>
<li>Other: <code>sepBy</code>, <code>optional</code>, <code>satisfy</code></li>
</ul>
</section>
<section id="dogfooding" class="level2">
<h2>Dogfooding</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="kw">class</span> (<span class="dt">Alternative</span> m,<span class="dt">MonadPlus</span> m) <span class="ot">=&gt;</span> <span class="dt">CharParser</span> m <span class="kw">where</span></div>
<div class="sourceLine" id="2" href="#2" data-line-number="2"><span class="ot">  satisfy ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> m <span class="dt">Char</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3"></div>
<div class="sourceLine" id="4" href="#4" data-line-number="4"><span class="ot">char ::</span> <span class="dt">CharParser</span> m <span class="ot">=&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> m <span class="dt">Char</span></div>
<div class="sourceLine" id="5" href="#5" data-line-number="5">char c <span class="fu">=</span> satisfy (c <span class="fu">==</span>)</div>
<div class="sourceLine" id="6" href="#6" data-line-number="6"></div>
<div class="sourceLine" id="7" href="#7" data-line-number="7"><span class="ot">parens ::</span> (<span class="dt">CharParser</span> m) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m a</div>
<div class="sourceLine" id="8" href="#8" data-line-number="8">parens p <span class="fu">=</span> char <span class="ch">&#39;(&#39;</span> <span class="fu">*&gt;</span> p <span class="fu">&lt;*</span> char <span class="ch">&#39;)&#39;</span></div></code></pre>
</section>
<section id="parse-you-a-lisp" class="level2">
<h2>Parse you a LISP</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span></div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">     <span class="dt">ENumber</span> <span class="dt">Scientific</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">   <span class="fu">|</span> <span class="dt">EString</span> <span class="dt">Text</span></div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">   <span class="fu">|</span> <span class="dt">EAtom</span> <span class="dt">Text</span></div>
<div class="sourceLine" id="5" href="#5" data-line-number="5">   <span class="fu">|</span> <span class="dt">EList</span> [<span class="dt">Expr</span>]</div>
<div class="sourceLine" id="6" href="#6" data-line-number="6"></div>
<div class="sourceLine" id="7" href="#7" data-line-number="7"><span class="ot">expr ::</span> <span class="dt">CharParsing</span> m <span class="ot">=&gt;</span> m <span class="dt">Expr</span></div>
<div class="sourceLine" id="8" href="#8" data-line-number="8">expr <span class="fu">=</span> (<span class="dt">ENumber</span> <span class="fu">&lt;$&gt;</span> scientific) <span class="fu">&lt;|&gt;</span></div>
<div class="sourceLine" id="9" href="#9" data-line-number="9">       (<span class="dt">EString</span> <span class="fu">&lt;$&gt;</span> stringLiteral) <span class="fu">&lt;|&gt;</span></div>
<div class="sourceLine" id="10" href="#10" data-line-number="10">       (<span class="dt">EAtom</span> <span class="fu">&lt;$&gt;</span> identifier) <span class="fu">&lt;|&gt;</span></div>
<div class="sourceLine" id="11" href="#11" data-line-number="11">       (<span class="dt">EList</span> <span class="fu">&lt;$&gt;</span> parens (sepBy expr spaces))</div></code></pre>
<pre class="sourceCode lisp"><code class="sourceCode commonlisp"><div class="sourceLine" id="1" href="#1" data-line-number="1">(<span class="kw">defun</span><span class="fu"> div </span>(a b)</div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">  <span class="st">&quot;Divide A by B and return rounded amount.&quot;</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">  (<span class="kw">if</span> (<span class="kw">eq</span> b <span class="dv">0</span>) (<span class="kw">error</span> <span class="st">&quot;Div by 0!&quot;</span>)</div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">    (<span class="kw">round</span> (<span class="op">/</span> a b))))</div></code></pre>
</section>
<section id="parse-you-a-lisp-1" class="level2">
<h2>Parse you a LISP</h2>
<pre class="sourceCode lisp"><code class="sourceCode commonlisp"><div class="sourceLine" id="1" href="#1" data-line-number="1">(<span class="kw">defun</span><span class="fu"> div </span>(a b)</div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">  <span class="st">&quot;Divide A by B and return rounded amount.&quot;</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">  (<span class="kw">if</span> (<span class="kw">eq</span> b <span class="dv">0</span>) (<span class="kw">error</span> <span class="st">&quot;Div by 0!&quot;</span>)</div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">    (<span class="kw">round</span> (<span class="op">/</span> a b))))</div></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="dt">EList</span> [<span class="dt">EAtom</span> <span class="st">&quot;defun&quot;</span>, <span class="dt">EAtom</span> <span class="st">&quot;div&quot;</span>, <span class="dt">EList</span> [<span class="dt">EAtom</span> <span class="st">&quot;a&quot;</span>, <span class="dt">EAtom</span> <span class="st">&quot;b&quot;</span>]</div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">  , <span class="dt">EString</span> <span class="st">&quot;Divide A by B and return rounded amount.&quot;</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">  , <span class="dt">EList</span> [<span class="dt">EAtom</span> <span class="st">&quot;if&quot;</span>, <span class="dt">EList</span> [<span class="dt">EAtom</span> <span class="st">&quot;eq&quot;</span>, <span class="dt">EAtom</span> <span class="st">&quot;b&quot;</span>, <span class="dt">ENumber</span> <span class="dv">0</span>]</div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">          , <span class="dt">EList</span> [<span class="dt">EAtom</span> <span class="st">&quot;error&quot;</span>, <span class="dt">EString</span> <span class="st">&quot;Div by 0!&quot;</span>]</div>
<div class="sourceLine" id="5" href="#5" data-line-number="5">          , <span class="dt">EList</span> [<span class="dt">EAtom</span> <span class="st">&quot;round&quot;</span></div>
<div class="sourceLine" id="6" href="#6" data-line-number="6">                  , <span class="dt">EList</span> [<span class="dt">EAtom</span> <span class="st">&quot;/&quot;</span>, <span class="dt">EAtom</span> <span class="st">&quot;a&quot;</span>, <span class="dt">EAtom</span> <span class="st">&quot;b&quot;</span>]]]]</div></code></pre>
</section>
</section>
<section id="my-war-musicxml" class="slide level1">
<h1>My War: MusicXML</h1>
<section id="section" class="level2">
<h2> </h2>
<p><img data-src="img/mywar-xml.png" /> <img data-src="img/henry-rollins.jpg" /> <img data-src="img/mywar-music.png" /></p>
</section>
<section id="the-problem" class="level2">
<h2>The Problem</h2>
<ul>
<li>I’ve generated a bunch of music data</li>
<li>I need to perform it with humans</li>
<li>I need to create decent sheet music</li>
<li>Lilypond jumps the shark, MusicABC too trivial</li>
</ul>
</section>
<section id="the-solution" class="level2">
<h2>The “Solution”</h2>
<ul>
<li>MusicXML, the “pro” way to go</li>
<li>Lots of printing support</li>
<li>In Java, use JAXB</li>
<li>In Haskell …</li>
</ul>
</section>
<section id="use-a-hand-rolled-musicxml-emitter-on-hackage" class="level2">
<h2>Use a hand-rolled MusicXML emitter on hackage</h2>
<ul>
<li>Only implements whatever the author got around to</li>
<li>Only supports author’s idiosyncratic music lib</li>
<li>MusicXML v2.0 only</li>
</ul>
</section>
<section id="wait-i-have-a-terrible-idea" class="level2">
<h2>Wait! I have a terrible idea</h2>
<ul>
<li>MusicXML fully specified in XSD</li>
<li>Ooh look a library to spit out DSLs from XSD!</li>
<li>Ooh look it’s been abandoned since 2011</li>
</ul>
<p><em>(rolls up sleeves)</em></p>
</section>
<section id="lets-generate-a-musicxml-library-from-xsd" class="level2">
<h2>Let’s generate a MusicXML library from XSD</h2>
<ul>
<li>Generate a DSL that will always correctly spit out XML</li>
<li>Load XSD as an AST</li>
<li>Need to “recognize” streams of XSD XML</li>
</ul>
</section>
<section id="huh-that-sounds-a-lot-like-a-parser" class="level2">
<h2>Huh, that sounds a lot like a … parser</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="co">-- | Recognize attribute group</span></div>
<div class="sourceLine" id="2" href="#2" data-line-number="2"><span class="ot">attributeGroup ::</span> <span class="dt">XParser</span> m <span class="ot">=&gt;</span> m <span class="dt">AttributeGroup</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">attributeGroup <span class="fu">=</span> <span class="kw">do</span></div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">  atEl (xsName <span class="st">&quot;attributeGroup&quot;</span>)</div>
<div class="sourceLine" id="5" href="#5" data-line-number="5">  <span class="dt">AttributeGroup</span> <span class="fu">.</span> qn <span class="fu">&lt;$&gt;</span> attr (name <span class="st">&quot;name&quot;</span>)</div>
<div class="sourceLine" id="6" href="#6" data-line-number="6">        <span class="fu">&lt;*&gt;</span> attrs <span class="fu">&lt;*&gt;</span> documentation</div>
<div class="sourceLine" id="7" href="#7" data-line-number="7">     <span class="fu">&lt;|&gt;</span> (<span class="dt">AttributeGroupRef</span> <span class="fu">.</span> <span class="dt">Unresolved</span> <span class="fu">.</span> qn)</div>
<div class="sourceLine" id="8" href="#8" data-line-number="8">        <span class="fu">&lt;$&gt;</span> attr (name <span class="st">&quot;ref&quot;</span>)</div>
<div class="sourceLine" id="9" href="#9" data-line-number="9"></div>
<div class="sourceLine" id="10" href="#10" data-line-number="10"><span class="co">-- | Recognize attributes and attributeGroups</span></div>
<div class="sourceLine" id="11" href="#11" data-line-number="11"><span class="co">--   (which often come together).</span></div>
<div class="sourceLine" id="12" href="#12" data-line-number="12"><span class="ot">attrs ::</span> <span class="dt">XParser</span> m <span class="ot">=&gt;</span> m <span class="dt">Attributes</span></div>
<div class="sourceLine" id="13" href="#13" data-line-number="13">attrs <span class="fu">=</span> <span class="dt">Attributes</span> <span class="fu">&lt;$&gt;</span></div>
<div class="sourceLine" id="14" href="#14" data-line-number="14">    findChildren (xsName <span class="st">&quot;attribute&quot;</span>) attribute <span class="fu">&lt;*&gt;</span></div>
<div class="sourceLine" id="15" href="#15" data-line-number="15">    findChildren (xsName <span class="st">&quot;attributeGroup&quot;</span>) attributeGroup</div></code></pre>
</section>
</section>
<section id="xml-element-parser-combinator" class="slide level1">
<h1>XML element parser combinator</h1>
<section id="take-1-statet-list-except" class="level2">
<h2>Take 1: StateT List + Except</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="co">-- | XParser constraint kind. Stack state + alternative + errors.</span></div>
<div class="sourceLine" id="2" href="#2" data-line-number="2"><span class="kw">type</span> <span class="dt">XParser</span> m <span class="fu">=</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">  (<span class="dt">Alternative</span> m, <span class="dt">MonadState</span> [<span class="dt">X.Element</span>] m, <span class="dt">MonadError</span> <span class="dt">String</span> m)</div>
<div class="sourceLine" id="4" href="#4" data-line-number="4"></div>
<div class="sourceLine" id="5" href="#5" data-line-number="5"><span class="co">-- | run XParser on an element.</span></div>
<div class="sourceLine" id="6" href="#6" data-line-number="6"><span class="ot">parseX ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">StateT</span> [<span class="dt">X.Element</span>] (<span class="dt">ExceptT</span> <span class="dt">String</span> m) b</div>
<div class="sourceLine" id="7" href="#7" data-line-number="7">       <span class="ot">-&gt;</span> <span class="dt">X.Element</span> <span class="ot">-&gt;</span> m (<span class="dt">Either</span> <span class="dt">String</span> b)</div>
<div class="sourceLine" id="8" href="#8" data-line-number="8">parseX sel e <span class="fu">=</span> runExceptT (evalStateT sel [e])</div></code></pre>
<p>Just like that, <code>&lt;|&gt;</code>, <code>optional</code>, failure/try/catch …</p>
</section>
<section id="build-you-a-musicxml-dsl-emitter" class="level2">
<h2>Build you a MusicXML DSL emitter</h2>
<ul>
<li>Was able to parse the entire MusicXML XSD (~4500 lines)</li>
<li>Generated a monster Haskell module (~8000 lines)</li>
<li>Shipped the piece</li>
</ul>
</section>
<section id="but-not-a-musicxml-reader" class="level2">
<h2>But not a MusicXML reader</h2>
<ul>
<li>Wanted to also <em>read</em> MusicXML to populate the DSL</li>
<li><code>XParser</code> unable to preserve element order (not needed in the MusicXML XSD)</li>
<li>Bad <code>try</code> semantics (no way to fail to parent)</li>
</ul>
</section>
<section id="take-2-statet-cursor-except" class="level2">
<h2>Take 2: StateT Cursor + Except</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.XML.Light.Cursor</span> <span class="kw">as</span> <span class="dt">C</span></div>
<div class="sourceLine" id="2" href="#2" data-line-number="2"></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3"><span class="kw">newtype</span> <span class="dt">XParse</span> a <span class="fu">=</span> <span class="dt">XParse</span></div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">    {<span class="ot"> unXParse ::</span> <span class="dt">StateT</span> <span class="dt">C.Cursor</span> (<span class="dt">Except</span> <span class="dt">XErrors</span>) a }</div>
<div class="sourceLine" id="5" href="#5" data-line-number="5">  <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Applicative</span>,<span class="dt">Monad</span>,<span class="dt">MonadState</span> <span class="dt">C.Cursor</span>,</div>
<div class="sourceLine" id="6" href="#6" data-line-number="6">            <span class="dt">MonadError</span> <span class="dt">XErrors</span>,<span class="dt">Alternative</span>)</div>
<div class="sourceLine" id="7" href="#7" data-line-number="7"></div>
<div class="sourceLine" id="8" href="#8" data-line-number="8"><span class="ot">runXParse ::</span> <span class="dt">X.Element</span> <span class="ot">-&gt;</span> <span class="dt">XParse</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">XErrors</span> a</div>
<div class="sourceLine" id="9" href="#9" data-line-number="9">runXParse e act <span class="fu">=</span></div>
<div class="sourceLine" id="10" href="#10" data-line-number="10">  runExcept (evalStateT (unXParse act) (C.fromElement e))</div></code></pre>
</section>
<section id="a-two-headed-beast" class="level2">
<h2>A two-headed beast</h2>
<ul>
<li>New parser works for codegen MusicXML reading (module now ~11,500 lines)</li>
<li>Wasn’t able to quickly replace the old XSD parser</li>
<li>Future work: bootstrap from the XSD XSD</li>
</ul>
</section>
</section>
<section id="the-pact-parser-and-compiler" class="slide level1">
<h1>The Pact Parser and Compiler</h1>
<section id="what-is-pact" class="level2">
<h2>What is Pact?</h2>
<ul>
<li>LISP/sexp syntax smart contract language</li>
<li>Part of the Kadena blockchain platform</li>
<li>Key/value DB language, public-key multisig support</li>
<li>Turing incomplete: strict, no recursion, no lambdas</li>
<li>Type inference, partial application, map/filter/fold/compose</li>
<li>Formal verification via embedded DSL, direct compilation to SMT-LIB2</li>
</ul>
</section>
<section id="pact-parsercompiler-v1" class="level2">
<h2>Pact Parser/Compiler, v1</h2>
<ul>
<li>Parser: coded using <code>parsers</code>, from <code>Text</code> to <code>Exp</code></li>
<li>Parse with <code>trifecta</code> in SDK, <code>attoparsec</code> on blockchain</li>
<li>“Compiler” written in spaghetti Haskell: from <code>Exp</code> to <code>Term Name</code></li>
</ul>
</section>
<section id="compiler-v1-pattern-matching-for-days" class="level2">
<h2>Compiler v1: Pattern matching for days</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="ot">defconst ::</span> [<span class="dt">Exp</span>] <span class="ot">-&gt;</span> <span class="dt">Info</span> <span class="ot">-&gt;</span> <span class="dt">Compile</span> (<span class="dt">Term</span> <span class="dt">Name</span>)</div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">defconst es i <span class="fu">=</span> <span class="kw">case</span> es <span class="kw">of</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">  [<span class="dt">EAtom</span> dn <span class="dt">Nothing</span> ct _,t] <span class="ot">-&gt;</span> mkConst dn ct t <span class="dt">Nothing</span></div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">  [<span class="dt">EAtom</span> dn <span class="dt">Nothing</span> ct _,t,<span class="dt">ELitString</span> docs] <span class="ot">-&gt;</span></div>
<div class="sourceLine" id="5" href="#5" data-line-number="5">    mkConst dn ct t (justDocs docs)</div>
<div class="sourceLine" id="6" href="#6" data-line-number="6">  [<span class="dt">EAtom</span> dn <span class="dt">Nothing</span> ct _,t,<span class="dt">EList&#39;</span> (<span class="dt">ELitString</span> docs<span class="fu">:</span>ps)] <span class="ot">-&gt;</span></div>
<div class="sourceLine" id="7" href="#7" data-line-number="7">    mkMeta docs ps <span class="fu">&gt;&gt;=</span> \m <span class="ot">-&gt;</span> mkConst dn ct t m</div>
<div class="sourceLine" id="8" href="#8" data-line-number="8">  _ <span class="ot">-&gt;</span> syntaxError i <span class="st">&quot;Invalid defconst&quot;</span></div>
<div class="sourceLine" id="9" href="#9" data-line-number="9">  <span class="kw">where</span></div>
<div class="sourceLine" id="10" href="#10" data-line-number="10">    mkConst dn ty v docs <span class="fu">=</span> <span class="kw">do</span></div>
<div class="sourceLine" id="11" href="#11" data-line-number="11">      v&#39; <span class="ot">&lt;-</span> run v</div>
<div class="sourceLine" id="12" href="#12" data-line-number="12">      cm <span class="ot">&lt;-</span> currentModule i</div>
<div class="sourceLine" id="13" href="#13" data-line-number="13">      a <span class="ot">&lt;-</span> <span class="dt">Arg</span> <span class="fu">&lt;$&gt;</span> pure dn <span class="fu">&lt;*&gt;</span> maybeTyVar i ty <span class="fu">&lt;*&gt;</span> pure i</div>
<div class="sourceLine" id="14" href="#14" data-line-number="14">      return <span class="fu">$</span> <span class="dt">TConst</span> a (fst cm) (<span class="dt">CVRaw</span> v&#39;) docs i</div></code></pre>
</section>
<section id="pattern-based-recognition" class="level2">
<h2>Pattern-based recognition</h2>
<ul>
<li>Hard to reuse matching logic</li>
<li>Pattern syms not enough</li>
<li>Hard to factor</li>
<li>Fast and “just works”</li>
</ul>
</section>
<section id="embedding-a-fv-dsl-in-pact" class="level2">
<h2>Embedding a FV DSL in Pact</h2>
<pre class="sourceCode lisp"><code class="sourceCode commonlisp"><div class="sourceLine" id="1" href="#1" data-line-number="1">(module accounts &#39;accounts-admin-keyset</div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">  @model [(defproperty conserves-mass</div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">            (<span class="op">=</span> (column-delta &#39;accounts &#39;balance) <span class="fl">0.0</span>))]</div>
<div class="sourceLine" id="4" href="#4" data-line-number="4"></div>
<div class="sourceLine" id="5" href="#5" data-line-number="5">  (defschema account</div>
<div class="sourceLine" id="6" href="#6" data-line-number="6">    @model (invariant (<span class="op">&gt;=</span> balance <span class="fl">0.0</span>))</div>
<div class="sourceLine" id="7" href="#7" data-line-number="7">    balance:decimal</div>
<div class="sourceLine" id="8" href="#8" data-line-number="8">    auth:keyset)</div>
<div class="sourceLine" id="9" href="#9" data-line-number="9">  (deftable accounts:{account})</div>
<div class="sourceLine" id="10" href="#10" data-line-number="10"></div>
<div class="sourceLine" id="11" href="#11" data-line-number="11">  (<span class="kw">defun</span><span class="fu"> transfer </span>(src:string dest:string amount:decimal)</div>
<div class="sourceLine" id="12" href="#12" data-line-number="12">    @model (property conserves-mass)</div>
<div class="sourceLine" id="13" href="#13" data-line-number="13">    (debit src amount)</div>
<div class="sourceLine" id="14" href="#14" data-line-number="14">    (credit dest amount)) ...</div></code></pre>
</section>
<section id="embedding-a-fv-dsl-in-pact-1" class="level2">
<h2>Embedding a FV DSL in Pact</h2>
<ul>
<li>Pact parser “too smart”</li>
<li>E.g., all literal types recognized in parser</li>
<li>Need “sexps only”</li>
</ul>
</section>
<section id="the-pact-parser-v2" class="level2">
<h2>The Pact Parser, v2</h2>
<p>Emit a drastically simplified <code>Exp</code> of lists, atoms, literals and delimters</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="kw">data</span> <span class="dt">Exp</span> i <span class="fu">=</span></div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">  <span class="dt">ELiteral</span> (<span class="dt">LiteralExp</span> i) <span class="fu">|</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">  <span class="dt">EAtom</span> (<span class="dt">AtomExp</span> i) <span class="fu">|</span></div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">  <span class="dt">EList</span> (<span class="dt">ListExp</span> i) <span class="fu">|</span></div>
<div class="sourceLine" id="5" href="#5" data-line-number="5">  <span class="dt">ESeparator</span> (<span class="dt">SeparatorExp</span> i)</div>
<div class="sourceLine" id="6" href="#6" data-line-number="6">  <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Generic</span>,<span class="dt">Functor</span>,<span class="dt">Foldable</span>,<span class="dt">Traversable</span>)</div></code></pre>
</section>
<section id="but-what-about-the-compiler" class="level2">
<h2>But what about the compiler</h2>
<ul>
<li>Major refactor</li>
<li>Compiler has to work with a far less rich <code>Exp</code></li>
<li>Wouldn’t it be nice if we could “parse” over <code>Exp</code>?</li>
</ul>
</section>
<section id="parsing-over-exp-asts" class="level2">
<h2>Parsing over <code>Exp</code> ASTs</h2>
<p>Start with the “better XML parser” shape, with homebrew cursor</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cursor</span> <span class="fu">=</span> <span class="dt">Cursor</span></div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">  {<span class="ot"> _cContext ::</span> <span class="dt">Maybe</span> (<span class="dt">Cursor</span>,<span class="dt">Exp</span> <span class="dt">Info</span>)</div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">  ,<span class="ot"> _cStream ::</span> [<span class="dt">Exp</span> <span class="dt">Info</span>] }</div>
<div class="sourceLine" id="4" href="#4" data-line-number="4"></div>
<div class="sourceLine" id="5" href="#5" data-line-number="5"><span class="kw">type</span> <span class="dt">ExpParser</span> a <span class="fu">=</span> <span class="dt">StateT</span> <span class="dt">Cursor</span> (<span class="dt">Except</span> <span class="dt">PactError</span>) a</div></code></pre>
</section>
<section id="problems-with-statet-except" class="level2">
<h2>Problems with StateT + Except</h2>
<ul>
<li><code>Except</code> is too blunt a tool
<ul>
<li>Unclear when an alternative “commits”</li>
</ul></li>
<li><code>State</code> overly general
<ul>
<li>Complex handling for tree-backed backtracking</li>
</ul></li>
<li>Excessive need for <code>try</code></li>
<li>Probably slow</li>
<li>Why not … look at what “real” parsers do</li>
</ul>
</section>
</section>
<section id="how-parsers-work" class="slide level1">
<h1>How Parsers Work</h1>
<section id="continuation-passing-for-days" class="level2">
<h2>Continuation Passing For Days</h2>
<p><img data-src="img/parsers.png" /></p>
</section>
<section id="just-mangle-four-continuations-whats-the-problem" class="level2">
<h2>Just mangle four continuations, what’s the problem?</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="co">-- Parsec Monad bind</span></div>
<div class="sourceLine" id="2" href="#2" data-line-number="2"><span class="ot">parserBind ::</span> <span class="dt">ParsecT</span> s u m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">ParsecT</span> s u m b)</div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">           <span class="ot">-&gt;</span> <span class="dt">ParsecT</span> s u m b</div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">parserBind m k <span class="fu">=</span> <span class="dt">ParsecT</span> <span class="fu">$</span> \s cok cerr eok eerr <span class="ot">-&gt;</span></div>
<div class="sourceLine" id="5" href="#5" data-line-number="5">  <span class="kw">let</span> mcok x s err <span class="fu">=</span></div>
<div class="sourceLine" id="6" href="#6" data-line-number="6">        <span class="kw">let</span> peok x s err&#39; <span class="fu">=</span> cok x s (mergeError err err&#39;)</div>
<div class="sourceLine" id="7" href="#7" data-line-number="7">            peerr err&#39;    <span class="fu">=</span> cerr (mergeError err err&#39;)</div>
<div class="sourceLine" id="8" href="#8" data-line-number="8">        <span class="kw">in</span>  unParser (k x) s cok cerr peok peerr</div>
<div class="sourceLine" id="9" href="#9" data-line-number="9">      meok x s err <span class="fu">=</span></div>
<div class="sourceLine" id="10" href="#10" data-line-number="10">        <span class="kw">let</span> peok x s err&#39; <span class="fu">=</span> eok x s (mergeError err err&#39;)</div>
<div class="sourceLine" id="11" href="#11" data-line-number="11">            peerr err&#39;    <span class="fu">=</span> eerr (mergeError err err&#39;)</div>
<div class="sourceLine" id="12" href="#12" data-line-number="12">        <span class="kw">in</span>  unParser (k x) s cok cerr peok peerr</div>
<div class="sourceLine" id="13" href="#13" data-line-number="13">  <span class="kw">in</span> unParser m s mcok cerr meok eerr</div></code></pre>
</section>
<section id="path-following-state-modeled-as-cp" class="level2">
<h2>Path-following state modeled as CP</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1">parserBind m k <span class="fu">=</span> <span class="dt">ParsecT</span> <span class="fu">$</span> \s cok         cerr eok eerr <span class="ot">-&gt;</span></div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">                 <span class="co">--           ^ commit-ok ^ commit-error</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">  <span class="kw">let</span> mcok x s err <span class="fu">=</span></div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">        <span class="kw">let</span> peok x s err&#39; <span class="fu">=</span> cok x s (mergeError err err&#39;)</div>
<div class="sourceLine" id="5" href="#5" data-line-number="5">            <span class="co">--              ^ routes to commit-ok!</span></div>
<div class="sourceLine" id="6" href="#6" data-line-number="6">            peerr err&#39;    <span class="fu">=</span> cerr (mergeError err err&#39;)</div>
<div class="sourceLine" id="7" href="#7" data-line-number="7">            <span class="co">--              ^ routes to commit-error!</span></div>
<div class="sourceLine" id="8" href="#8" data-line-number="8">        <span class="kw">in</span> unParser (k x) s cok cerr peok     peerr</div>
<div class="sourceLine" id="9" href="#9" data-line-number="9">           <span class="co">--                        ^ eps-ok ^ eps-err</span></div>
<div class="sourceLine" id="10" href="#10" data-line-number="10">      <span class="fu">...</span></div>
<div class="sourceLine" id="11" href="#11" data-line-number="11">  <span class="kw">in</span> unParser m s mcok cerr meok eerr</div>
<div class="sourceLine" id="12" href="#12" data-line-number="12">     <span class="co">--           ^ commit path</span></div></code></pre>
<p>Commit path “re-routes” epsilon paths</p>
</section>
<section id="path-following-state-modeled-as-cp-1" class="level2">
<h2>Path-following state modeled as CP</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1">parserBind m k <span class="fu">=</span> <span class="dt">ParsecT</span> <span class="fu">$</span> \s cok cerr eok      eerr <span class="ot">-&gt;</span></div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">                 <span class="co">--                    ^ eps-ok ^ eps-error</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">  <span class="kw">let</span> <span class="fu">...</span></div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">      meok x s err <span class="fu">=</span></div>
<div class="sourceLine" id="5" href="#5" data-line-number="5">        <span class="kw">let</span> peok x s err&#39; <span class="fu">=</span> eok x s (mergeError err err&#39;)</div>
<div class="sourceLine" id="6" href="#6" data-line-number="6">            peerr err&#39;    <span class="fu">=</span> eerr (mergeError err err&#39;)</div>
<div class="sourceLine" id="7" href="#7" data-line-number="7">        <span class="kw">in</span>  unParser (k x) s cok cerr peok     peerr</div>
<div class="sourceLine" id="8" href="#8" data-line-number="8">            <span class="co">--                        ^ eps-ok ^ eps-err</span></div>
<div class="sourceLine" id="9" href="#9" data-line-number="9">  <span class="kw">in</span> unParser m s mcok cerr meok eerr</div>
<div class="sourceLine" id="10" href="#10" data-line-number="10">     <span class="co">--                     ^ epsilon path</span></div></code></pre>
<p>Epsilon path doesn’t re-route, just merges errors</p>
</section>
<section id="haskell-parser-semantics" class="level2">
<h2>Haskell Parser Semantics</h2>
<ul>
<li>Commit on “leftmost” item in a given alternative</li>
<li>Subsequent “epsilon” successes or failures stay on commit path</li>
<li>Longer success paths must happen in <code>try</code></li>
<li>[Atto not analyzed for this talk]</li>
</ul>
</section>
<section id="now-how-to-write-a-non-char-stream-parser" class="level2">
<h2>Now, how to write a non-<code>Char</code> stream parser?</h2>
<ul>
<li>Semantics are hard</li>
<li>Performance is harder</li>
<li>If only a parser library supported arbitrary streams …</li>
</ul>
</section>
</section>
<section id="megaparsec-6.x-to-the-rescue" class="slide level1">
<h1>Megaparsec 6.x to the rescue</h1>
<section id="stream-typeclass-for-arbitrary-input-streams" class="level2">
<h2><code>Stream</code> typeclass for arbitrary input streams</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="kw">class</span> (<span class="dt">Stream</span> s, <span class="dt">MonadPlus</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadParsec</span> e s m <span class="kw">where</span> <span class="fu">...</span></div></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="kw">class</span> (<span class="dt">Ord</span> (<span class="dt">Token</span> s), <span class="dt">Ord</span> (<span class="dt">Tokens</span> s)) <span class="ot">=&gt;</span> <span class="dt">Stream</span> s <span class="kw">where</span></div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">  <span class="kw">type</span> <span class="dt">Token</span><span class="ot"> s ::</span> <span class="fu">*</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">  <span class="kw">type</span> <span class="dt">Tokens</span><span class="ot"> s ::</span> <span class="fu">*</span></div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">  <span class="fu">...</span></div></code></pre>
</section>
<section id="getinput-setinput-for-include-files" class="level2">
<h2><code>getInput</code>, <code>setInput</code> for “include files”</h2>
<ul>
<li>Allows arbitrary re-setting of <code>Stream</code> data</li>
<li>Intended to support includes</li>
<li>Includes <em>a.k.a.</em> sourcefile trees</li>
<li><code>Exp</code> ASTs, XML bodies: trees</li>
</ul>
</section>
<section id="need-current-thing" class="level2">
<h2>Need “current thing”</h2>
<ul>
<li>Char parsers don’t need to see what we just parsed</li>
<li>Need some extra state to show the current <code>Exp</code></li>
<li>Good thing <code>MonadParsec</code> has all the instances!</li>
</ul>
</section>
<section id="and-were-done" class="level2">
<h2>And we’re done!</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Stream</span> <span class="dt">Cursor</span> <span class="kw">where</span></div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">  <span class="kw">type</span> <span class="dt">Token</span> <span class="dt">Cursor</span> <span class="fu">=</span> <span class="dt">Exp</span> <span class="dt">Info</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">  <span class="kw">type</span> <span class="dt">Tokens</span> <span class="dt">Cursor</span> <span class="fu">=</span> [<span class="dt">Exp</span> <span class="dt">Info</span>]</div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">  <span class="fu">...</span></div>
<div class="sourceLine" id="5" href="#5" data-line-number="5"></div>
<div class="sourceLine" id="6" href="#6" data-line-number="6"><span class="kw">data</span> <span class="dt">ParseState</span> a <span class="fu">=</span> <span class="dt">ParseState</span></div>
<div class="sourceLine" id="7" href="#7" data-line-number="7">  {<span class="ot"> _psCurrent ::</span> (<span class="dt">Exp</span> <span class="dt">Info</span>) }</div>
<div class="sourceLine" id="8" href="#8" data-line-number="8"></div>
<div class="sourceLine" id="9" href="#9" data-line-number="9"><span class="kw">type</span> <span class="dt">ExpParse</span> s a <span class="fu">=</span> <span class="dt">StateT</span> (<span class="dt">ParseState</span> s) (<span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Cursor</span>) a</div></code></pre>
</section>
<section id="are-we-done" class="level2">
<h2>Are we done?</h2>
<p>When parsing sexps, we’d like <code>specialForm</code> to recognize the first atom, otherwise assume we’re doing normal LISP function application.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="ot">sexp ::</span> <span class="dt">Compile</span> (<span class="dt">Term</span> <span class="dt">Name</span>)</div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">sexp <span class="fu">=</span> withList&#39; <span class="dt">Parens</span> (specialForm <span class="fu">&lt;|&gt;</span> app)</div></code></pre>
<pre class="sourceCode lisp"><code class="sourceCode commonlisp"><div class="sourceLine" id="1" href="#1" data-line-number="1">(<span class="kw">let</span> ((a <span class="dv">1</span>)) a) <span class="co">;; special form</span></div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">(use accounts)  <span class="co">;; special form</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)         <span class="co">;; apply `+`</span></div></code></pre>
</section>
<section id="sexp-special-form-or-app" class="level2">
<h2>Sexp: special form or app</h2>
<p><code>specialForm</code> recognizes a “bare atom” and switches on text, while <code>app</code> accepts bare, qualified and typed atoms.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="ot">specialForm ::</span> <span class="dt">Compile</span> (<span class="dt">Term</span> <span class="dt">Name</span>)</div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">specialForm <span class="fu">=</span> bareAtom <span class="fu">&gt;&gt;=</span> \<span class="dt">AtomExp</span>{<span class="fu">..</span>} <span class="ot">-&gt;</span> <span class="kw">case</span> _atomAtom <span class="kw">of</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">    <span class="st">&quot;use&quot;</span> <span class="ot">-&gt;</span> useForm</div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">    <span class="st">&quot;let&quot;</span> <span class="ot">-&gt;</span> letForm</div>
<div class="sourceLine" id="5" href="#5" data-line-number="5">    <span class="fu">...</span></div>
<div class="sourceLine" id="6" href="#6" data-line-number="6">    _ <span class="ot">-&gt;</span> expected <span class="st">&quot;special form&quot;</span></div>
<div class="sourceLine" id="7" href="#7" data-line-number="7"></div>
<div class="sourceLine" id="8" href="#8" data-line-number="8"><span class="ot">app ::</span> <span class="dt">Compile</span> (<span class="dt">Term</span> <span class="dt">Name</span>)</div>
<div class="sourceLine" id="9" href="#9" data-line-number="9">app <span class="fu">=</span> <span class="kw">do</span></div>
<div class="sourceLine" id="10" href="#10" data-line-number="10">  v <span class="ot">&lt;-</span> varAtom</div>
<div class="sourceLine" id="11" href="#11" data-line-number="11">  body <span class="ot">&lt;-</span> many (term <span class="fu">&lt;|&gt;</span> bindingForm)</div>
<div class="sourceLine" id="12" href="#12" data-line-number="12">  <span class="dt">TApp</span> v body <span class="fu">&lt;$&gt;</span> contextInfo</div></code></pre>
</section>
<section id="delegatingfactored-combinators" class="level2">
<h2>Delegating/factored combinators</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="ot">atom ::</span> <span class="dt">ExpParse</span> s (<span class="dt">AtomExp</span> <span class="dt">Info</span>)</div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">atom <span class="fu">=</span> fst <span class="fu">&lt;$&gt;</span> exp <span class="st">&quot;atom&quot;</span> _EAtom</div>
<div class="sourceLine" id="3" href="#3" data-line-number="3"></div>
<div class="sourceLine" id="4" href="#4" data-line-number="4"><span class="ot">bareAtom ::</span> <span class="dt">ExpParse</span> s (<span class="dt">AtomExp</span> <span class="dt">Info</span>)</div>
<div class="sourceLine" id="5" href="#5" data-line-number="5">bareAtom <span class="fu">=</span> atom <span class="fu">&gt;&gt;=</span> \a<span class="fu">@</span><span class="dt">AtomExp</span>{<span class="fu">..</span>} <span class="ot">-&gt;</span> <span class="kw">case</span> _atomQualifiers <span class="kw">of</span></div>
<div class="sourceLine" id="6" href="#6" data-line-number="6">  (_<span class="fu">:</span>_) <span class="ot">-&gt;</span> expected <span class="st">&quot;unqualified atom&quot;</span></div>
<div class="sourceLine" id="7" href="#7" data-line-number="7">  [] <span class="ot">-&gt;</span> return a</div></code></pre>
<p><code>bareAtom</code> delegates to the <code>atom</code> combinator.</p>
</section>
<section id="exp-the-base-case-exp-test" class="level2">
<h2><code>exp</code>, the base case <code>Exp</code> test</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1">exp<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Prism&#39;</span> (<span class="dt">Exp</span> <span class="dt">Info</span>) a <span class="ot">-&gt;</span> <span class="dt">ExpParse</span> s (a,<span class="dt">Exp</span> <span class="dt">Info</span>)</div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">exp ty prism <span class="fu">=</span> <span class="kw">do</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">  <span class="kw">let</span> test i <span class="fu">=</span> <span class="kw">case</span> firstOf prism i <span class="kw">of</span></div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">        <span class="dt">Just</span> a <span class="ot">-&gt;</span> <span class="dt">Right</span> (a,i)</div>
<div class="sourceLine" id="5" href="#5" data-line-number="5">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> err i (<span class="st">&quot;Expected: &quot;</span> <span class="fu">++</span> ty)</div>
<div class="sourceLine" id="6" href="#6" data-line-number="6">      err i s <span class="fu">=</span> <span class="fu">...</span></div>
<div class="sourceLine" id="7" href="#7" data-line-number="7">  r <span class="ot">&lt;-</span> lift <span class="fu">$</span> token test</div>
<div class="sourceLine" id="8" href="#8" data-line-number="8">  return r</div></code></pre>
<p><code>atom</code> uses <code>exp</code> to apply a <code>Prism</code> to the <code>Exp</code> that is at the cursor, via <code>token</code>.</p>
</section>
<section id="token-the-hook-into-megaparsec" class="level2">
<h2><code>token</code>, the hook into Megaparsec</h2>
<p><code>exp</code> uses megaparsec’s <code>token</code>, which hooks into megaparsec’s semantics.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="kw">class</span> (<span class="dt">Stream</span> s, <span class="dt">MonadPlus</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadParsec</span> e s m <span class="kw">where</span> <span class="fu">...</span></div>
<div class="sourceLine" id="2" href="#2" data-line-number="2"><span class="ot">  token ::</span> (<span class="dt">Token</span> s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)) <span class="ot">-&gt;</span> m a</div></code></pre>
<p>The <code>(Token s -&gt; Maybe a)</code> argument is the predicate to indicate success.</p>
</section>
<section id="quiz-where-does-commit-happen" class="level2">
<h2>Quiz: where does commit happen?</h2>
<ul>
<li><code>sexp</code></li>
<li><code>specialForm</code></li>
<li><code>app</code></li>
<li><code>bareAtom</code></li>
<li><code>atom</code></li>
</ul>
</section>
<section id="atom-way-too-soon" class="level2">
<h2><code>atom</code>: way too soon</h2>
<ul>
<li>Consider a bad let: <code>(let (foo bar))</code></li>
<li><code>letForm</code> would discover error</li>
<li>But error context would be at top of <code>specialForm</code></li>
<li>i.e., terrible UX</li>
<li><code>try</code> around <code>specialForm</code> could fail to <code>app</code></li>
</ul>
</section>
<section id="the-problem-with-non-char-parsers" class="level2">
<h2>The problem with non-Char parsers</h2>
<ul>
<li><code>token</code> commits on the first test
<ul>
<li><code>Char</code>-based parsers <em>never introspect on a string</em></li>
<li>Thus a single “leftmost term” test suffices</li>
</ul></li>
<li>Whereas an <code>Exp</code> parser needs to introspect:
<ul>
<li>atom? + unqualified? + atom text is correct?</li>
</ul></li>
<li><code>try</code> can’t represent certain paths</li>
<li><code>try</code> is slow as a base case</li>
</ul>
</section>
<section id="so-now-what" class="level2">
<h2>So now what?</h2>
<ul>
<li><code>token</code> is the only way in and uses predicates</li>
<li>Model low-level combinators as predicates</li>
<li>Requires a different shape for “pre-commit” combinators
<ul>
<li>would probably need “committing” versions too</li>
</ul></li>
<li>Yuck!</li>
</ul>
</section>
</section>
<section id="hacking-a-non-char-megaparsec" class="slide level1">
<h1>Hacking a non-Char Megaparsec</h1>
<section id="a-better-solution-controlled-commit" class="level2">
<h2>A better solution: controlled commit</h2>
<ul>
<li>Need an “epsilon <code>token</code>” to linger on the epsilon path</li>
<li>Need an <em>explicit combinator</em> to switch to commit path</li>
<li>Need clear semantics on when commit occurs</li>
</ul>
</section>
<section id="explicit-commit-the-easy-part" class="level2">
<h2>Explicit commit: the easy part</h2>
<p>Simply create a “commit OK” combinator</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="co">-- | Call commit continuation with current state.</span></div>
<div class="sourceLine" id="2" href="#2" data-line-number="2"><span class="ot">pCommit ::</span> forall e s m<span class="fu">.</span> <span class="dt">ParsecT</span> e s m ()</div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">pCommit <span class="fu">=</span> <span class="dt">ParsecT</span> <span class="fu">$</span> \s cok _ _ _ <span class="ot">-&gt;</span> cok () s mempty</div>
<div class="sourceLine" id="4" href="#4" data-line-number="4"></div>
<div class="sourceLine" id="5" href="#5" data-line-number="5"><span class="co">-- | Commit any previous recognitions.</span></div>
<div class="sourceLine" id="6" href="#6" data-line-number="6"><span class="ot">commit ::</span> <span class="dt">ExpParse</span> s ()</div>
<div class="sourceLine" id="7" href="#7" data-line-number="7">commit <span class="fu">=</span> lift pCommit</div></code></pre>
</section>
<section id="epsilon-token-hacky-copypasta" class="level2">
<h2>Epsilon Token: hacky copypasta</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="ot">pTokenEpsilon ::</span></div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">  <span class="dt">Stream</span> s <span class="ot">=&gt;</span> (<span class="dt">Token</span> s <span class="ot">-&gt;</span> <span class="dt">S.Set</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)))</div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Token</span> s) <span class="ot">-&gt;</span> <span class="dt">ParsecT</span> e s m a</div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">pTokenEpsilon test <span class="fu">=</span></div>
<div class="sourceLine" id="5" href="#5" data-line-number="5">  <span class="dt">ParsecT</span> <span class="fu">$</span> \s<span class="fu">@</span>(<span class="dt">State</span> input (pos<span class="fu">:|</span>z) tp w) _ _ eok eerr <span class="ot">-&gt;</span></div>
<div class="sourceLine" id="6" href="#6" data-line-number="6">    <span class="kw">case</span> take1_ input <span class="kw">of</span></div>
<div class="sourceLine" id="7" href="#7" data-line-number="7">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> eerr <span class="fu">...</span></div>
<div class="sourceLine" id="8" href="#8" data-line-number="8">      <span class="dt">Just</span> (c,cs) <span class="ot">-&gt;</span> <span class="kw">case</span> test c <span class="kw">of</span></div>
<div class="sourceLine" id="9" href="#9" data-line-number="9">        <span class="dt">Left</span> (us, ps) <span class="ot">-&gt;</span> eerr <span class="fu">...</span></div>
<div class="sourceLine" id="10" href="#10" data-line-number="10">        <span class="dt">Right</span> x <span class="ot">-&gt;</span></div>
<div class="sourceLine" id="11" href="#11" data-line-number="11">          <span class="kw">let</span> <span class="fu">!</span>npos <span class="fu">=</span> advance1 (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> s) w pos c</div>
<div class="sourceLine" id="12" href="#12" data-line-number="12">              newstate <span class="fu">=</span> <span class="dt">State</span> cs (npos<span class="fu">:|</span>z) (tp <span class="fu">+</span> <span class="dv">1</span>) w</div>
<div class="sourceLine" id="13" href="#13" data-line-number="13">          <span class="kw">in</span> eok x newstate mempty</div>
<div class="sourceLine" id="14" href="#14" data-line-number="14">          <span class="co">-- ^ only change from original &#39;token&#39; is `cok` -&gt; `eok`</span></div></code></pre>
</section>
<section id="success" class="level2">
<h2>Success!</h2>
<ul>
<li><code>exp</code> uses <code>pTokenEpsilon</code>, non-committing</li>
<li>“low-level” combinators (<code>atom</code> etc) don’t commit</li>
<li>Examples of committing combinators:
<ul>
<li>list entering (<code>withList'</code> etc)</li>
<li><code>symbol</code> (single-path bare atom text)</li>
<li><code>sep</code> (<code>exp</code> + separator match)</li>
</ul></li>
<li>otherwise user code explicitly <code>commit</code>s</li>
</ul>
</section>
<section id="explicit-commit-in-action" class="level2">
<h2>Explicit commit in action</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" href="#1" data-line-number="1"><span class="ot">specialForm ::</span> <span class="dt">Compile</span> (<span class="dt">Term</span> <span class="dt">Name</span>)</div>
<div class="sourceLine" id="2" href="#2" data-line-number="2">specialForm <span class="fu">=</span> bareAtom <span class="fu">&gt;&gt;=</span> \<span class="dt">AtomExp</span>{<span class="fu">..</span>} <span class="ot">-&gt;</span> <span class="kw">case</span> _atomAtom <span class="kw">of</span></div>
<div class="sourceLine" id="3" href="#3" data-line-number="3">    <span class="st">&quot;use&quot;</span> <span class="ot">-&gt;</span> commit <span class="fu">&gt;&gt;</span> useForm</div>
<div class="sourceLine" id="4" href="#4" data-line-number="4">    <span class="st">&quot;let&quot;</span> <span class="ot">-&gt;</span> commit <span class="fu">&gt;&gt;</span> letForm</div>
<div class="sourceLine" id="5" href="#5" data-line-number="5">    <span class="st">&quot;let*&quot;</span> <span class="ot">-&gt;</span> commit <span class="fu">&gt;&gt;</span> letsForm</div>
<div class="sourceLine" id="6" href="#6" data-line-number="6">    <span class="st">&quot;defconst&quot;</span> <span class="ot">-&gt;</span> commit <span class="fu">&gt;&gt;</span> defconst</div>
<div class="sourceLine" id="7" href="#7" data-line-number="7">    <span class="st">&quot;step&quot;</span> <span class="ot">-&gt;</span> commit <span class="fu">&gt;&gt;</span> step</div>
<div class="sourceLine" id="8" href="#8" data-line-number="8">    <span class="st">&quot;step-with-rollback&quot;</span> <span class="ot">-&gt;</span> commit <span class="fu">&gt;&gt;</span> stepWithRollback</div>
<div class="sourceLine" id="9" href="#9" data-line-number="9">    <span class="st">&quot;bless&quot;</span> <span class="ot">-&gt;</span> commit <span class="fu">&gt;&gt;</span> bless</div>
<div class="sourceLine" id="10" href="#10" data-line-number="10">    <span class="st">&quot;deftable&quot;</span> <span class="ot">-&gt;</span> commit <span class="fu">&gt;&gt;</span> deftable</div>
<div class="sourceLine" id="11" href="#11" data-line-number="11">    <span class="st">&quot;defschema&quot;</span> <span class="ot">-&gt;</span> commit <span class="fu">&gt;&gt;</span> defschema</div>
<div class="sourceLine" id="12" href="#12" data-line-number="12">    <span class="st">&quot;defun&quot;</span> <span class="ot">-&gt;</span> commit <span class="fu">&gt;&gt;</span> defun</div>
<div class="sourceLine" id="13" href="#13" data-line-number="13">    <span class="st">&quot;defpact&quot;</span> <span class="ot">-&gt;</span> commit <span class="fu">&gt;&gt;</span> defpact</div>
<div class="sourceLine" id="14" href="#14" data-line-number="14">    <span class="st">&quot;module&quot;</span> <span class="ot">-&gt;</span> commit <span class="fu">&gt;&gt;</span> moduleForm</div>
<div class="sourceLine" id="15" href="#15" data-line-number="15">    _ <span class="ot">-&gt;</span> expected <span class="st">&quot;special form&quot;</span></div></code></pre>
</section>
</section>
<section id="postscript" class="slide level1">
<h1>Postscript</h1>
<section id="wtf-is-simplifier-ticks-exhausted" class="level2">
<h2>WTF is “Simplifier ticks exhausted”?</h2>
<p>Add a single <code>INLINE</code> to Pact.Compile and …</p>
<pre><code>[72 of 87] Compiling Pact.Compile     ( src/Pact/Compile.hs, .stack-work/dist/x86_64-osx/Cabal-1.24.2.0/build/Pact/Compile.o )
ghc: panic! (the &#39;impossible&#39; happened)
  (GHC version 8.0.2 for x86_64-apple-darwin):
    Simplifier ticks exhausted
  When trying RuleFired ++
  To increase the limit, use -fsimpl-tick-factor=N (default 100)
  If you need to do this, let GHC HQ know, and what factor you needed
  To see detailed counts use -ddump-simpl-stats
  Total ticks: 200681

Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug</code></pre>
</section>
</section>
<section id="thank-you" class="slide level1">
<h1>Thank You!</h1>
<p>Stuart Popejoy stuart@kadena.io <span class="citation" data-cites="SirLensALot">@SirLensALot</span></p>
<p>Pact <br><a href="https://github.com/kadena-io/pact" class="uri">https://github.com/kadena-io/pact</a></p>
<p>Fadno-XML <br><a href="https://hackage.haskell.org/package/fadno-xml" class="uri">https://hackage.haskell.org/package/fadno-xml</a></p>
<p>Megaparsec <br><a href="http://hackage.haskell.org/package/megaparsec" class="uri">http://hackage.haskell.org/package/megaparsec</a></p>
<p>This talk<br> <a href="http://slpopejoy.github.io/talks/parsing-ny-haskell-2018.html" class="uri">http://slpopejoy.github.io/talks/parsing-ny-haskell-2018.html</a></p>
</section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
