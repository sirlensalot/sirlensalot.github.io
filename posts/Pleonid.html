<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>tatterdemalion - Algorithmic Compositional Techniques Developed for "Pleonid"</title>
        <meta name="viewport" content="width=device-width">
<link rel="stylesheet" type="text/css" href="../fonts/Sans/cmun-sans.css" />
<link rel="stylesheet" type="text/css" href="../fonts/cmun-serif.css" />
<link rel="stylesheet" type="text/css" href="../fonts/SerifSlanted/cmun-serif-slanted.css" />
<!-- <link rel="stylesheet" type="text/css" href="/css/screen.css"/> -->
<link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<link rel="stylesheet" type="text/css" href="../css/default.css" />

</head>
    <body>
        <div id="header">
            <div id="lefty">
                <a class="header_a" href="../">tatterdemalion</a>
            </div>
            <div id="navigation">
                <a href="../archive.html" class="header_a">archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Algorithmic Compositional Techniques Developed for "Pleonid"</h1>

            <div class="info">
    Posted on May 15, 2015
    
        by Stuart Popejoy
    
</div>

<p>“Pleonid” (2012, Stuart Popejoy) is an algorithmic composition for quintet. This paper describes the methods used for its creation, “warts and all”. It also discusses the advantages found after porting the entire composition from Java into Haskell, a typed functional programming language.</p>
<h1 id="generative-techniques-for-pitch-sequences">Generative Techniques for Pitch Sequences</h1>
<p>“Pleonid” employs a minimum of random or stochastic techniques preferring a generative, elaborative approach. The first phase of generation involves manipulating pitch sets to arrive at a series of pitch sequences, or “lines”, which will form the basis of the piece. The path to these lines is covered in this section.</p>
<p>The “seed” of the entire composition is a melodic sequence.</p>
<div class="figure">
<img alt="Seed melody of Pleonid." class="small" src="figures/pleonid/01-seed__small.png" />
<p class="caption">Seed melody of <em>Pleonid</em>.</p>
</div>
<p>This is normalized into a <em>pitch class set</em> of value <code>[0,2,3,4,5,7]</code> (No. 6-8 in Forte classification). Departing from set theory, I use this ordered sequence as a “scale” for further transformations.</p>
<div class="figure">
<img alt="Pitch class set and main scale." class="small" src="figures/pleonid/01a-seedScale__small.png" />
<p class="caption">Pitch class set and main scale.</p>
</div>
<h2 id="gamut">Gamut</h2>
<p>One of the properties of the sequence/scale is its range, namely that it is less than the 12-semitone range of a standard scale. The term “gamut” is used to describe this range, with 12 being the usual value in Western equal-tempered music. For our purposes, gamut is preferred to “octave” which invokes the chroma identity.</p>
<p>Using gamuts other than 12 create interest by effectively transposing pitches by register, as well as limiting or expanding the search space for intervals and melodies.</p>
<p>In this case of the pitch class set-sequence, the reduced range creates an effective gamut of 7. For many procedures in Pleonid I use a gamut of 10, such as for the “steerings” described below, mainly to create interesting non-octave symmetries. When we discuss orchestration below we’ll see 10 used again for its intervallic character.</p>
<h2 id="generating-n-ads">Generating N-ads</h2>
<p>The first transformation is to generate every chord or “sub-scale” that can be built from this scale/sequence.</p>
<p>The interval vector of the pitch set is used, that is the ordered intervals or deltas between the pitches: <code>[2,1,1,1,2]</code>. By enumerating every possible ordered sum of these values, I determine every chord or “N-ad” (dyad, triad, tetrad etc) that can be projected onto this sequence.</p>
<p>The function <code>genNAds</code> achieves this with concatenation of two recursive list comprehensions:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">genNAds ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]
genNAds []     <span class="fu">=</span> [[]]
genNAds (x<span class="fu">:</span>xs) <span class="fu">=</span> [x<span class="fu">:</span>ps <span class="fu">|</span> ps <span class="ot">&lt;-</span> genNAds xs] <span class="fu">++</span> 
                     [(x<span class="fu">+</span>p)<span class="fu">:</span>ps <span class="fu">|</span> p<span class="fu">:</span>ps <span class="ot">&lt;-</span> genNAds xs]</code></pre></div>
<p>This is a first illustration of the admirable expressiveness of functional programming. The corresponding Java code is considerably longer and more bug-prone. <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p>To illustrate, let’s take the sequence <code>C D E F</code>, whose intervals are <code>[2,2,1]</code>. The resulting tuples are <code>[[2,2,1],[2,3],[4,1],[5]]</code>.</p>
<div class="figure">
<img alt="Generating all N-ads from a sequence." class="small" src="figures/pleonid/02-genNAds__small.png" />
<p class="caption">Generating all “N-ads” from a sequence.</p>
</div>
<p>Performing this operation on the Pleonid interval vector <code>[2,1,1,1,2]</code> produces 16 tuples. Like the example, the final dyad simply bounds the scale, so I drop it as trivial/uninteresting. Note the full scale is the first tuple.</p>
<div class="figure">
<img alt="Pleonid scale tuples." src="figures/pleonid/02a-genNAdsPleonid.png" />
<p class="caption">Pleonid scale tuples.</p>
</div>
<h2 id="the-tone-clock">The Tone Clock</h2>
<p>The motivation for generating these interval sets, or chords, is to subdivide a scale or gamut in a way to generate diverse yet related intervallic material. The approach borrows from by procedures invented by the Dutch composer Peter Schat, called the “Tone Clock.” <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<p>The tone clock represents the 12 distinct triads that can be “set” into the 12-tone gamut. Triads are identified as <em>normalized, invertible</em> classes. Thus the major triad is represented as <code>(4,3)</code> and classified with its inverse, the minor triad <code>(3,4)</code>.</p>
<p>The 12-tone scale has 12 of these triad classes. Schat dubs these the “hours” of the “tone clock”. Each “hour” has a fixed number of configurations by which the triad class can be placed to saturate all notes of the scale.</p>
<p>In the case of the major/minor triad, hour “IX” on his clock, there are exactly two configurations: major/minor/major/minor at <code>0,2,6,8</code>, and minor/minor/major/major at <code>0,2,4,6</code>. Schat calls these configurations “steerings”, as if we were “steering” the chord through the 12-tone gamut.</p>
<div class="figure">
<img alt="Steerings of Hour IX, the major/minor triad class in the Tone Clock." src="figures/pleonid/03-ixSteerings.png" />
<p class="caption">Steerings of “Hour IX”, the major/minor triad class in the Tone Clock.</p>
</div>
<p>Each triad class or “hour” has a fixed number of configuration “steerings”, with 33 total configurations over all classes. Each configuration can be seen as producing a tetrad of the bottom-note placements. <a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
<h2 id="steerings-in-pleonid">Steerings in Pleonid</h2>
<p>The classification and steering of a triad can be applied to apply to any N-ad. Clearly a dyad or a tetrad can be configured the same way within the scale. Of course, with more than 2 intervals, we are no longer simply “inverting” the chord but <em>rotating</em> it, such that for the tetrad <code>(1,3,2)</code> we have <code>(3,2,1)</code> and <code>(2,1,3)</code>.</p>
<div class="figure">
<img alt="Rotations of the tetrad (1,3,2)." class="small" src="figures/pleonid/03a-tetradRotation__small.png" />
<p class="caption">Rotations of the tetrad (1,3,2).</p>
</div>
<p>Likewise, the gamut can be other values than 12.</p>
<p>With different chord sizes and gamuts, total saturation (i.e., “using up” all of the gamut values with a steering configuration) becomes difficult or impossible. In Pleonid this requirement is removed, instead searching for <em>maximal</em> instead of <em>total</em> saturation.</p>
<p>By relaxing this constraint, I was able to “steer” most tuples below 1/2 the size of the gamut of 10. Even so, some chords do not “steer”, either because the note count is too large, or the intervals do not permit any further placements.</p>
<h2 id="steering-algorithm">Steering algorithm</h2>
<p>The search for all valid configurations of a tuple class in a gamut begins with the observation that every N-ad is steered by another “M-ad” where <code>M</code> is N divided by the gamut. Thus a 5-tuple is steered by some dyad (2-tuple) in a 10-gamut.</p>
<p>Thus the search space is every possible “steering” M-ad in the gamut, configured with every possible rotation of the N-ad placed in each “slot” in the M-ad. Collisions are invalidated, and duplicates removed, producing a final result of valid configurations.</p>
<p>For example, finding all steerings of the 5-tuple <code>(2,1,2,2)</code> in a 10-gamut means searching every possible dyad (90 total) with every possible rotation (4 total) resulting in 360 candidates. Some optimizations are possible, for instance dyads having intervals larger than 1/2 the gamut size are “un-steerable”. For this 5-tuple, just 2 steerings are found.</p>
<div class="figure">
<img alt="Steering (2,1,2,2) in a 10-gamut." src="figures/pleonid/05-pleoSteering3.png" />
<p class="caption">Steering (2,1,2,2) in a 10-gamut.</p>
</div>
<p>The last tuple of the second steering is noteworthy, as the last note is “gamut-wrapped”. The rotation of the interval is <code>(2,2,1,2)</code> but since the last note goes above the gamut boundary (Bb), it must be “wrapped” (modulo) for the gamut, resulting in the C# pitch instead of a B.</p>
<p>This is one way non-standard gamuts create interest. In a 12-gamut the chroma would be identical: a D above the octave “sounds the same” as the D below. Here, C# sounds quite different than B, adding new pitch information to the composition.</p>
<p>This is performed for the 15 scale tuples shown above. Only 3 tuples are “un-steerable,” while the rest were quite productive, producing 49 distinct steerings.</p>
<h2 id="preserving-seed-melody-features-or-not">Preserving seed melody features (or not)</h2>
<p>The 49 steerings created have an almost random character, except for their “source” being an interval derived from the scale tuples. To amplify the intervallic character, the steerings are filtered by a rule where at least one of the steering tuples must be built from the seed scale.</p>
<p>With the <code>[0,2,3,4,5,7]</code> seed scale, the steering <code>[0,2,3,5,7],[4,6,8,9,1]</code> is allowed, since the first tuple <code>[0,2,3,5,7]</code> can be built from the seed scale. Meanwhile, the steering <code>[0,1,3,5,7],[2,4,6,8,9]</code> is discarded, since both tuples have notes outside of the seed scale.</p>
<p>This filter reduces the 49 steerings to 32. The tuples then undergo a mapping procedure, intended to map any scale tones back to the register they appear in the original seed sequence. So for instance, if a <code>G</code> appears in a chord, it would be mapped to below middle-C.</p>
<div class="figure">
<img alt="Intended mapping of pitches onto original seed sequence." src="figures/pleonid/06-mappingCorrect.png" />
<p class="caption">Intended mapping of pitches onto original seed sequence.</p>
</div>
<p>This mapping procedure did not go as planned however! A bug in the original Java code resulted in a more or less random mapping.</p>
<div class="figure">
<img alt="Buggy mapping makes for unplanned results." src="figures/pleonid/07-mappingIncorrect.png" />
<p class="caption">Buggy mapping makes for unplanned results.</p>
</div>
<p>Thus the attempt to “preserve seed melody features” more or less fails. The filtering above prefers tuples carrying the seed-scale pitches, but the buggy mapping affects seed-scale pitches <em>more</em> than non-seed-scale ones. Thus these very pitches are the most distorted. At least, the mapping succeeds in adding some intervallic interest to a gamut-limited set of chords.</p>
<p>This bug was only discovered during the port to Haskell. Like much combinatorial code in Java, the mapping code was creaky and complex, while the Haskell code is concise and far simpler. I now have both methods, the broken and the correct one. Future works will choose which “sounds better”. So much for formal purity!</p>
<h2 id="lines-from-chords">Lines from chords</h2>
<p>We now have 32 steerings, which group tuples of a particular size: 2 5-tuples, or 3 3-tuples, etc. Melodies are generated from this by simply interleaving the values to create a longer line.</p>
<div class="figure">
<img alt="Interleaving steerings to generate lines." src="figures/pleonid/08-interleave.png" />
<p class="caption">Interleaving steerings to generate lines.</p>
</div>
<p>To maximize interest, monotonically increasing or decreasing lines – lines that only move in one direction – are discarded. Interestingly this results in only one result filtered.</p>
<p>This results in 31 lines, which form the foundation of the actual musical composition. We’re ready to create real musical ideas.</p>
<h1 id="rhythm-melody-motif-braids">Rhythm + Melody = Motif: Braids</h1>
<p>The next step in composing Pleonid is to use the pitch information in the lines to produce rhythmic information. This is accomplished by projecting the pitch sequences into a “strand” and using this to generate a “braid” of contrapuntally-related motives.</p>
<p>My concept of braids borrows from <em>knot theory</em> in mathematics, in which idealized knots or braids are formalized as polynomials, and categorized by salient features such as how many crosses occur, how many strands are being tied, etc. <a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<p>A braid in Pleonid is derived from the “braid representation” of a knot. It is a two-dimensional representation, of fixed dimension, where strands cross over and under each other as they move horizontally.<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a></p>
<div class="figure">
<img alt="A braid from Pleonid. The numbers index the vertical position to pitches." src="figures/pleonid/braid_strands_05-20x7.png" />
<p class="caption">A braid from Pleonid. The numbers index the vertical position to pitches.</p>
</div>
<p>In Pleonid, all of these features are given musical meaning.</p>
<h2 id="braid-musical-features">Braid musical features</h2>
<p>A braid is built from “strands” which proceed from left to right; as such, each strand represents a voice changing pitch in time. Positions on the x-axis are fixed time intervals (like an eighth note). Positions on the y-axis are <em>indexed</em> to a scale, instead of a direct y-axis representation of pitch. A chromatic scale would therefore reproduce the y-axis values.</p>
<p>In braids, any change in y-position indicates a <em>cross</em>, meaning an adjacent strand will make the complementary change at the same x-position. The cross has a particular <em>polarity</em> such that one strand is crossing “over” the other.</p>
<p>For musical assignment, an <code>UNDER</code> cross is seen as a “hidden” pitch change, meaning the previous pitch still plays for that unit of time. An <code>OVER</code> cross means an immediate shift to the indexed pitch.</p>
<h2 id="projecting-a-pitch-sequence-as-a-strand">Projecting a pitch sequence as a strand</h2>
<p>To generate a braid, we first “project” a pitch sequence as a <em>strand</em>. An index is made from the sorted set of all pitches used, so that pitches will be plotted on the y-axis at their index.</p>
<p>Strands are built from “steps” defined as a pitch index value and a “weave”, which is an instruction for how to move to the next step. Weaves indicate if the move is <code>UP</code>, <code>DOWN</code>, or <code>FLAT</code>, as well as whether the move is <code>UNDER</code> or <code>OVER</code> (for non-<code>FLAT</code> weaves).</p>
<p>The algorithm locates the next pitch index in the sequence. If adjacent to the current index, it assigns an <code>OVER</code> transition with <code>UP</code> or <code>DOWN</code>. If the pitch index is the same, it assigns <code>FLAT</code>.</p>
<p>If the pitch index is not adjacent, it assigns <code>UNDER</code>, with a direction <code>UP</code> or <code>DOWN</code> which will “lead to” the next index. This continues until the next pitch index is reached.</p>
<p>The process repeats until the last pitch, which does not need its own “step” since the index has already been determined by the steps leading up to it.</p>
<div class="figure">
<img alt="The source line." class="small" src="figures/pleonid/10-strandSource__small.png" />
<p class="caption">The source line.</p>
</div>
<div class="figure">
<img alt="The strand generated from the source line." src="figures/pleonid/strand_05.png" />
<p class="caption">The strand generated from the source line.</p>
</div>
<p>The resulting rhythmic behavior of the projection turns the pitch sequence into a motive. A strange feature of the strand realization is the last pitch. Since there is no “step” governing it, it is assigned an “extra” time value.</p>
<div class="figure">
<img alt="The strand realized as motive." src="figures/pleonid/11-strandResult.png" />
<p class="caption">The strand realized as motive.</p>
</div>
<h2 id="braid-generation-from-a-strand-contrapuntal-motives">Braid generation from a strand: contrapuntal motives</h2>
<p>With the single strand, braid crossing rules indicate how other strands might interact with the source strand. To fill an entire braid however requires a generation algorithm. The approach taken is to generate one “column” at a time, starting with the first “step” of the braid and moving forward.</p>
<p>Within a given column, generation proceeds from the step’s row upwards, simply iterating a fixed order of “weaves” (<code>DOWN_UNDER</code>, <code>UP_OVER</code>, <code>FLAT</code>, <code>DOWN_OVER</code>, <code>UP_UNDER</code>), starting from the weave at the step. This produces a “terraced” effect of flat alternating with crosses; plus, the crosses switch “polarity” (<code>OVER</code> vs <code>UNDER</code>) for additional diversity.</p>
<p>This is then repeated downward from the step, with the terracing order reversed. In the original code, the downward generator loses the “polarity switch” effect (a bug); in the Haskell version this quirk is offered as an option.</p>
<p>Finally, a “capping” rule is applied. Braids cannot have an upward cross from the top position, nor a downward cross from the bottom, so these are coverted to <code>FLAT</code>.</p>
<div class="figure">
<img alt="Filling a braid from a single strand. The terraced generator results are shown on odd columns only, to illustrate the columnar algorithm." class="small" src="figures/pleonid/strand_tcol_01__small.png" />
<p class="caption">Filling a braid from a single strand. The “terraced” generator results are shown on odd columns only, to illustrate the columnar algorithm.</p>
</div>
<div class="figure">
<img alt="The resulting braid." class="small" src="figures/pleonid/braid_strands_01-11x6__small.png" />
<p class="caption">The resulting braid.</p>
</div>
<p>Thus the full braids are generated. Each strand generated is a different motif, but within the same scale, and lasting the same amount of time, as the source strand.</p>
<h2 id="braid-sequences">Braid “sequences”</h2>
<p>An key feature of braids is the representation of a <em>loop</em> within a knot, where a strand “loops back” to make a different cross, potentially with itself or a distinct strand.</p>
<p>In a braid, a loop is indicated by a strand ending on a different y-position than where it starts. This “extends” the strand to the beginning of the strand starting at the end position. This continues until a strand’s ending position points back at the first strand’s starting position. <a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a></p>
<p>Since “loop” has a different connotation in music, I call these longer, joined strands <em>sequences</em>. Sequences can consume every strand in a braid, or a braid can have two or three sequences, or just one-strand sequences with no loops.</p>
<div class="figure">
<img alt="Sequences of a braid." src="figures/pleonid/braid_seqs_13-20x7.png" />
<p class="caption">“Sequences” of a braid.</p>
</div>
<p>In the figure, the strand starting at index 10 ends at index 9, thus looping to the strand at index 9. This strand ends at 10 completing the loop as a two-strand sequence. The strand at 8 ends at 8, so it is a one-strand sequence. Finally, the strands at 6, 0, 5 and 1 join as a 4-strand sequence.</p>
<p>Sequences add an interesting “metric” dimension to braids. While sequences are potentially of different length, they will always be a multiple of the strand length. This creates “multi-bar” longer motives, with the shorter motives repeating at the “bar” interval.</p>
<div class="figure">
<img alt="Braid sequences realized." src="figures/pleonid/braid-13.png" />
<p class="caption">Braid sequences realized.</p>
</div>
<p>The figure shows a realization of the three sequences from the braid above, transposed a 10th apart from each other. The 4-sequence is on the top staff, lasting 4 bars. The 1-sequence in the middle repeates 4 times, while the 2-seauence on the bottom staff repeats twice.</p>
<h1 id="braid-chords">Braid Chords</h1>
<p>I also chose 10 as a register “layout” for the quintet instrumentation. 10, the “dominant 7” interval, is near the major- and minor-sixth interval that makes for sonorous and pleasing voicings. Meanwhile each voice ends up with a harmonic/melodic “neighborhood” distinct from the other instruments.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Credit is due to “Cale” on the #haskell IRC channel for producing this brilliant formation in response to my desperate plea for help. There were other equally delightful offers, one using monadic list notation.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Schat, Peter (1993). Also see <a href="http://en.wikipedia.org/wiki/Tone_Clock" class="uri">http://en.wikipedia.org/wiki/Tone_Clock</a> and <a href="http://www.peterschat.nl/clockwise.html" class="uri">http://www.peterschat.nl/clockwise.html</a>. Thanks to Jochem van Dijk for hipping me to it.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>For Schat these tetrads can be related intervallically to other triad hours in the clock, producing a relationship between hours.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Knot theory is obscure but has contributions from Markov and others, with applications in bioinformatics, fluid mechanics, cryptography. See <a href="http://en.wikipedia.org/wiki/Knot_theory" class="uri">http://en.wikipedia.org/wiki/Knot_theory</a>.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>See <a href="http://katlas.org/wiki/Braid_Representatives" class="uri">http://katlas.org/wiki/Braid_Representatives</a> for examples of braid generation from knots in Mathematica.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>The well-formed-ness of braids is a fascinating topic in math, with braids forming a formal group with an identity and an inverse operation. See <a href="http://en.wikipedia.org/wiki/Braid_group" class="uri">http://en.wikipedia.org/wiki/Braid_group</a>.<a href="#fnref6">↩</a></p></li>
</ol>
</div>

        </div>
        <div id="footer">
		  <div id="lefty">
			<a href="https://github.com/slpopejoy/tatterdemalion">sources</a>
		  </div>
          <a href="http://jaspervdj.be/hakyll">hakyll</a>
		    
        </div>
    </body>
</html>
